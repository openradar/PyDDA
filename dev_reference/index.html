
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Developer Reference Manual &#8212; PyDDA 1.2.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pydda.cost_functions.J_function" href="generated/pydda.cost_functions.J_function.html" />
    <link rel="prev" title="Example on geographic plotting and constraint variation" href="../source/auto_examples/plot_fun_with_constraints.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">PyDDA</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../contributors_guide/index.html">
  Contributor’s Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../source/auto_examples/index.html">
  PyDDA Example Gallery
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Developer Reference Manual
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.J_function.html">
   pydda.cost_functions.J_function
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.grad_J.html">
   pydda.cost_functions.grad_J
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_radial_vel_cost_function.html">
   pydda.cost_functions.calculate_radial_vel_cost_function
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_grad_radial_vel.html">
   pydda.cost_functions.calculate_grad_radial_vel
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_mass_continuity.html">
   pydda.cost_functions.calculate_mass_continuity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_mass_continuity_gradient.html">
   pydda.cost_functions.calculate_mass_continuity_gradient
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_smoothness_cost.html">
   pydda.cost_functions.calculate_smoothness_cost
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_smoothness_gradient.html">
   pydda.cost_functions.calculate_smoothness_gradient
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_background_cost.html">
   pydda.cost_functions.calculate_background_cost
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_background_gradient.html">
   pydda.cost_functions.calculate_background_gradient
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_vertical_vorticity_cost.html">
   pydda.cost_functions.calculate_vertical_vorticity_cost
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_vertical_vorticity_gradient.html">
   pydda.cost_functions.calculate_vertical_vorticity_gradient
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_model_cost.html">
   pydda.cost_functions.calculate_model_cost
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_model_gradient.html">
   pydda.cost_functions.calculate_model_gradient
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_fall_speed.html">
   pydda.cost_functions.calculate_fall_speed
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_point_cost.html">
   pydda.cost_functions.calculate_point_cost
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.cost_functions.calculate_point_gradient.html">
   pydda.cost_functions.calculate_point_gradient
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.retrieval.get_dd_wind_field.html">
   pydda.retrieval.get_dd_wind_field
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.retrieval.get_bca.html">
   pydda.retrieval.get_bca
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.retrieval.DDParameters.html">
   pydda.retrieval.DDParameters
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_barbs.html">
   pydda.vis.plot_horiz_xsection_barbs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_barbs.html">
   pydda.vis.plot_xz_xsection_barbs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_barbs.html">
   pydda.vis.plot_yz_xsection_barbs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_barbs_map.html">
   pydda.vis.plot_horiz_xsection_barbs_map
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_streamlines.html">
   pydda.vis.plot_horiz_xsection_streamlines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_streamlines.html">
   pydda.vis.plot_xz_xsection_streamlines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_streamlines.html">
   pydda.vis.plot_yz_xsection_streamlines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_streamlines_map.html">
   pydda.vis.plot_horiz_xsection_streamlines_map
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_quiver.html">
   pydda.vis.plot_horiz_xsection_quiver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_quiver.html">
   pydda.vis.plot_xz_xsection_quiver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_quiver.html">
   pydda.vis.plot_yz_xsection_quiver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_quiver_map.html">
   pydda.vis.plot_horiz_xsection_quiver_map
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.initialization.make_constant_wind_field.html">
   pydda.initialization.make_constant_wind_field
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.initialization.make_wind_field_from_profile.html">
   pydda.initialization.make_wind_field_from_profile
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.initialization.make_background_from_wrf.html">
   pydda.initialization.make_background_from_wrf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.initialization.make_initialization_from_era_interim.html">
   pydda.initialization.make_initialization_from_era_interim
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.constraints.make_constraint_from_wrf.html">
   pydda.constraints.make_constraint_from_wrf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.constraints.add_hrrr_constraint_to_grid.html">
   pydda.constraints.add_hrrr_constraint_to_grid
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.constraints.make_constraint_from_era_interim.html">
   pydda.constraints.make_constraint_from_era_interim
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.constraints.download_needed_era_data.html">
   pydda.constraints.download_needed_era_data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generated/pydda.constraints.get_iem_obs.html">
   pydda.constraints.get_iem_obs
  </a>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cost-functions-module">
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     cost_functions
    </span>
   </code>
   Module
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pydda-cost-functions-pydda-cost-functions">
     pydda.cost_functions (pydda.cost_functions)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#retrieval-module">
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     retrieval
    </span>
   </code>
   Module
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pydda-retrieval-pydda-retrieval">
     pydda.retrieval (pydda.retrieval)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vis-module">
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     vis
    </span>
   </code>
   Module
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pydda-vis-pydda-vis">
     pydda.vis (pydda.vis)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#initalization-module">
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     initalization
    </span>
   </code>
   Module
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pydda-initialization-pydda-initialization">
     pydda.initialization (pydda.initialization)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constraints-module">
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     constraints
    </span>
   </code>
   Module
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pydda-constraints-pydda-constraints">
     pydda.constraints (pydda.constraints)
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="developer-reference-manual">
<span id="user"></span><h1>Developer Reference Manual<a class="headerlink" href="#developer-reference-manual" title="Permalink to this headline">#</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Release</dt>
<dd class="field-odd"><p>1.2.0</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>Feb 14, 2023</p>
</dd>
</dl>
<p>This is the developer reference guide for PyDDA which covers most of the
available functions, modules, and classes.</p>
<section id="cost-functions-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">cost_functions</span></code> Module<a class="headerlink" href="#cost-functions-module" title="Permalink to this headline">#</a></h2>
<p>Module containing cost functions and their gradients.</p>
<span class="target" id="module-pydda.cost_functions"></span><section id="pydda-cost-functions-pydda-cost-functions">
<h3>pydda.cost_functions (pydda.cost_functions)<a class="headerlink" href="#pydda-cost-functions-pydda-cost-functions" title="Permalink to this headline">#</a></h3>
<p>The procedures in this module calculate the individual
cost functions and their gradients. All cost functions
output a single floating point value. All gradients to cost
functions will output an 1D numpy array whose shape is 3 x
the total number of grid points <em>N</em>. The first <em>N</em> points will
correspond to the gradient of the cost function for each value
of <em>u</em>, the second <em>N</em> points will correspond to the gradient of the
cost function for each value of <em>v</em>, and the third <em>N</em> points will
correspond to the gradient of the cost function for each value
of <em>w</em>.</p>
<p>In order to calculate the gradients of cost functions, assuming
that your cost function can be written as a functional in the form
of:</p>
<div class="math notranslate nohighlight">
\[J(\vec{u(x,y,z)}) = \int_{domain} f(\vec{u(x,y,z)}) dxdydz\]</div>
<p>Then, the gradient <span class="math notranslate nohighlight">\(\nabla J\)</span> is for each <span class="math notranslate nohighlight">\(u_{i} \in {\vec{u}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\delta J}{\delta u_{i}} = \frac{\delta f}{\delta u_{i}(x,y,z)} -
\frac{d}{dx}\frac{\delta f}{\delta u'_{i}(x,y,z)}\]</div>
<p>So, for a cost function such as:</p>
<div class="math notranslate nohighlight">
\[J(\vec{u}) = \int_{domain} (\vec{u}-\vec{u_{back}})^2 dxdydz\]</div>
<p>We get for each <span class="math notranslate nohighlight">\(u_{i} \in {\vec{u}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\delta J}{\delta u_{i}} = \frac{\delta f}{\delta u_{i}(x,y,z)} -
\frac{d}{dx}\frac{\delta L}{\delta u'_{i}(x,y,z)}\]</div>
<p>Since <span class="math notranslate nohighlight">\(f\)</span> does not depend on <span class="math notranslate nohighlight">\(u'_{i}(x,y,z)\)</span>, we have:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\frac{\delta J}{\delta u_{i}} = 2(u_{i}-\vec{u_{back}}) - 0\\\frac{\delta J}{\delta u_{i}} = 2(u_{i}-\vec{u_{back}})\end{aligned}\end{align} \]</div>
<p>Therefore, in order to add your own custom cost functions for your point
observation, you need to explicitly be able to write both the cost function
and its gradient using the methodology above. One you have implemented both
procedures in Python, they then need to be added to
<a class="reference internal" href="#module-pydda.cost_functions" title="pydda.cost_functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydda.cost_functions</span></code></a>.</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.J_function.html#pydda.cost_functions.J_function" title="pydda.cost_functions.J_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">J_function</span></code></a>(winds, parameters)</p></td>
<td><p>Calculates the total cost function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.grad_J.html#pydda.cost_functions.grad_J" title="pydda.cost_functions.grad_J"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grad_J</span></code></a>(winds, parameters)</p></td>
<td><p>Calculates the gradient of the cost function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_radial_vel_cost_function.html#pydda.cost_functions.calculate_radial_vel_cost_function" title="pydda.cost_functions.calculate_radial_vel_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_radial_vel_cost_function</span></code></a>(vrs, azs, ...)</p></td>
<td><p>Calculates the cost function due to difference of the wind field from radar radial velocities. For more information on this cost function, see Potvin et al. (2012) and Shapiro et al. (2009). All arrays in the given lists must have the same dimensions and represent the same spatial coordinates. :Parameters: * <strong>vrs</strong> (<em>List of float arrays</em>) -- List of radial velocities from each radar              * <strong>els</strong> (<em>List of float arrays</em>) -- List of elevations from each radar              * <strong>azs</strong> (<em>List of float arrays</em>) -- List of azimuths from each radar              * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>wts</strong> (<em>List of float arrays</em>) -- Float array containing fall speed from radar. * <strong>rmsVr</strong> (<em>float</em>) -- The sum of squares of velocity/num_points. Use for normalization                of data weighting coefficient              * <strong>weights</strong> (<em>n_radars x_bins x y_bins float array</em>) -- Data weights for each pair of radars              * <strong>coeff</strong> (<em>float</em>) -- Constant for cost function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_grad_radial_vel.html#pydda.cost_functions.calculate_grad_radial_vel" title="pydda.cost_functions.calculate_grad_radial_vel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_grad_radial_vel</span></code></a>(vrs, els, azs, u, ...)</p></td>
<td><p>Calculates the gradient of the cost function due to difference of wind field from radar radial velocities. All arrays in the given lists must have the same dimensions and represent the same spatial coordinates. :Parameters: * <strong>vrs</strong> (<em>List of float arrays</em>) -- List of radial velocities from each radar              * <strong>els</strong> (<em>List of float arrays</em>) -- List of elevations from each radar              * <strong>azs</strong> (<em>List of azimuths</em>) -- List of azimuths from each radar              * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>coeff</strong> (<em>float</em>) -- Constant for cost function              * <strong>vel_name</strong> (<em>str</em>) -- Background velocity field name              * <strong>weights</strong> (<em>n_radars x_bins x y_bins float array</em>) -- Data weights for each pair of radars.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_mass_continuity.html#pydda.cost_functions.calculate_mass_continuity" title="pydda.cost_functions.calculate_mass_continuity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_mass_continuity</span></code></a>(u, v, w, z, dx, dy, dz)</p></td>
<td><p>Calculates the mass continuity cost function by taking the divergence of the wind field. All arrays in the given lists must have the same dimensions and represent the same spatial coordinates. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>dx</strong> (<em>float</em>) -- Grid spacing in x direction. * <strong>dy</strong> (<em>float</em>) -- Grid spacing in y direction. * <strong>dz</strong> (<em>float</em>) -- Grid spacing in z direction. * <strong>z</strong> (<em>Float array (1D)</em>) -- 1D Float array with heights of grid              * <strong>coeff</strong> (<em>float</em>) -- Constant controlling contribution of mass continuity to cost function              * <strong>anel</strong> (<em>int</em>) -- = 1 use anelastic approximation, 0=don't.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_mass_continuity_gradient.html#pydda.cost_functions.calculate_mass_continuity_gradient" title="pydda.cost_functions.calculate_mass_continuity_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_mass_continuity_gradient</span></code></a>(u, v, w, ...)</p></td>
<td><p>Calculates the gradient of mass continuity cost function. This is done by taking the negative gradient of the divergence of the wind field. All grids must have the same grid specification. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>z</strong> (<em>Float array (1D)</em>) -- 1D Float array with heights of grid              * <strong>dx</strong> (<em>float</em>) -- Grid spacing in x direction. * <strong>dy</strong> (<em>float</em>) -- Grid spacing in y direction. * <strong>dz</strong> (<em>float</em>) -- Grid spacing in z direction. * <strong>coeff</strong> (<em>float</em>) -- Constant controlling contribution of mass continuity to cost function              * <strong>anel</strong> (<em>int</em>) -- = 1 use anelastic approximation, 0=don't.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_smoothness_cost.html#pydda.cost_functions.calculate_smoothness_cost" title="pydda.cost_functions.calculate_smoothness_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_smoothness_cost</span></code></a>(u, v, w[, Cx, Cy, Cz])</p></td>
<td><p>Calculates the smoothness cost function by taking the Laplacian of the wind field. All arrays in the given lists must have the same dimensions and represent the same spatial coordinates. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>Cx</strong> (<em>float</em>) -- Constant controlling smoothness in x-direction              * <strong>Cy</strong> (<em>float</em>) -- Constant controlling smoothness in y-direction              * <strong>Cz</strong> (<em>float</em>) -- Constant controlling smoothness in z-direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_smoothness_gradient.html#pydda.cost_functions.calculate_smoothness_gradient" title="pydda.cost_functions.calculate_smoothness_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_smoothness_gradient</span></code></a>(u, v, w[, Cx, ...])</p></td>
<td><p>Calculates the gradient of the smoothness cost function by taking the Laplacian of the Laplacian of the wind field. All arrays in the given lists must have the same dimensions and represent the same spatial coordinates. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>Cx</strong> (<em>float</em>) -- Constant controlling smoothness in x-direction              * <strong>Cy</strong> (<em>float</em>) -- Constant controlling smoothness in y-direction              * <strong>Cz</strong> (<em>float</em>) -- Constant controlling smoothness in z-direction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_background_cost.html#pydda.cost_functions.calculate_background_cost" title="pydda.cost_functions.calculate_background_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_background_cost</span></code></a>(u, v, w, weights, ...)</p></td>
<td><p>Calculates the background cost function. The background cost function is simply the sum of the squared differences between the wind field and the background wind field multiplied by the weighting coefficient. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>weights</strong> (<em>Float array</em>) -- Weights for each point to consider into cost function              * <strong>u_back</strong> (<em>1D float array</em>) -- Zonal winds vs height from sounding              * <strong>w_back</strong> (<em>1D float array</em>) -- Meridional winds vs height from sounding              * <strong>Cb</strong> (<em>float</em>) -- Weight of background constraint to total cost function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_background_gradient.html#pydda.cost_functions.calculate_background_gradient" title="pydda.cost_functions.calculate_background_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_background_gradient</span></code></a>(u, v, w, ...)</p></td>
<td><p>Calculates the gradient of the background cost function. For each u, v this is given as 2*coefficent*(analysis wind - background wind). :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>weights</strong> (<em>Float array</em>) -- Weights for each point to consider into cost function              * <strong>u_back</strong> (<em>1D float array</em>) -- Zonal winds vs height from sounding              * <strong>w_back</strong> (<em>1D float array</em>) -- Meridional winds vs height from sounding              * <strong>Cb</strong> (<em>float</em>) -- Weight of background constraint to total cost function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_vertical_vorticity_cost.html#pydda.cost_functions.calculate_vertical_vorticity_cost" title="pydda.cost_functions.calculate_vertical_vorticity_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_vertical_vorticity_cost</span></code></a>(u, v, w, ...)</p></td>
<td><p>Calculates the cost function due to deviance from vertical vorticity equation. For more information of the vertical vorticity cost function, see Potvin et al. (2012) and Shapiro et al. (2009). :Parameters: * <strong>u</strong> (<em>3D array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>3D array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>3D array</em>) -- Float array with w component of wind field              * <strong>dx</strong> (<em>float array</em>) -- Spacing in x grid              * <strong>dy</strong> (<em>float array</em>) -- Spacing in y grid              * <strong>dz</strong> (<em>float array</em>) -- Spacing in z grid              * <strong>coeff</strong> (<em>float</em>) -- Weighting coefficient              * <strong>Ut</strong> (<em>float</em>) -- U component of storm motion              * <strong>Vt</strong> (<em>float</em>) -- V component of storm motion.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_vertical_vorticity_gradient.html#pydda.cost_functions.calculate_vertical_vorticity_gradient" title="pydda.cost_functions.calculate_vertical_vorticity_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_vertical_vorticity_gradient</span></code></a>(u, v, ...)</p></td>
<td><p>Calculates the gradient of the cost function due to deviance from vertical vorticity equation. This is done by taking the functional derivative of the vertical vorticity cost function. :Parameters: * <strong>u</strong> (<em>3D array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>3D array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>3D array</em>) -- Float array with w component of wind field              * <strong>dx</strong> (<em>float array</em>) -- Spacing in x grid              * <strong>dy</strong> (<em>float array</em>) -- Spacing in y grid              * <strong>dz</strong> (<em>float array</em>) -- Spacing in z grid              * <strong>Ut</strong> (<em>float</em>) -- U component of storm motion              * <strong>Vt</strong> (<em>float</em>) -- V component of storm motion              * <strong>coeff</strong> (<em>float</em>) -- Weighting coefficient.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_model_cost.html#pydda.cost_functions.calculate_model_cost" title="pydda.cost_functions.calculate_model_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_model_cost</span></code></a>(u, v, w, weights, ...)</p></td>
<td><p>Calculates the cost function for the model constraint. This is calculated simply as the sum of squares of the differences between the model wind field and the analysis wind field. Vertical velocities are not factored into this cost function as there is typically a high amount of uncertainty in model derived vertical velocities. :Parameters: * <strong>u</strong> (<em>3D array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>3D array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>3D array</em>) -- Float array with w component of wind field              * <strong>weights</strong> (<em>list of 3D arrays</em>) -- Float array showing how much each point from model weighs into                constraint. * <strong>u_model</strong> (<em>list of 3D arrays</em>) -- Float array with u component of wind field from model              * <strong>v_model</strong> (<em>list of 3D arrays</em>) -- Float array with v component of wind field from model              * <strong>w_model</strong> (<em>list of 3D arrays</em>) -- Float array with w component of wind field from model              * <strong>coeff</strong> (<em>float</em>) -- Weighting coefficient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_model_gradient.html#pydda.cost_functions.calculate_model_gradient" title="pydda.cost_functions.calculate_model_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_model_gradient</span></code></a>(u, v, w, weights, ...)</p></td>
<td><p>Calculates the cost function for the model constraint. This is calculated simply as twice the differences between the model wind field and the analysis wind field for each u, v. Vertical velocities are not factored into this cost function as there is typically a high amount of uncertainty in model derived vertical velocities. Therefore, the gradient for all of the w's will be 0. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>w</strong> (<em>Float array</em>) -- Float array with w component of wind field              * <strong>weights</strong> (<em>list of 3D float arrays</em>) -- Weights for each point to consider into cost function              * <strong>u_model</strong> (<em>list of 3D float arrays</em>) -- Zonal wind field from model              * <strong>v_model</strong> (<em>list of 3D float arrays</em>) -- Meridional wind field from model              * <strong>w_model</strong> (<em>list of 3D float arrays</em>) -- Vertical wind field from model              * <strong>coeff</strong> (<em>float</em>) -- Weight of background constraint to total cost function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_fall_speed.html#pydda.cost_functions.calculate_fall_speed" title="pydda.cost_functions.calculate_fall_speed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_fall_speed</span></code></a>(grid[, refl_field, frz])</p></td>
<td><p>Estimates fall speed based on reflectivity. Uses methodology of Mike Biggerstaff and Dan Betten :Parameters: * <strong>Grid</strong> (<em>Py-ART Grid</em>) -- Py-ART Grid containing reflectivity to calculate fall speed from              * <strong>refl_field</strong> (<em>str</em>) -- String containing name of reflectivity field. None will automatically                determine the name. * <strong>frz</strong> (<em>float</em>) -- Height of freezing level in m.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_point_cost.html#pydda.cost_functions.calculate_point_cost" title="pydda.cost_functions.calculate_point_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_point_cost</span></code></a>(u, v, x, y, z, point_list)</p></td>
<td><p>Calculates the cost function related to point observations. A mean square error cost function term is applied to points that are within the sphere of influence whose radius is determined by <em>roi</em>. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>x</strong> (<em>Float array</em>) -- X coordinates of grid centers              * <strong>y</strong> (<em>Float array</em>) -- Y coordinates of grid centers              * <strong>z</strong> (<em>Float array</em>) -- Z coordinated of grid centers              * <strong>point_list</strong> (<em>list of dicts</em>) -- List of point constraints. Each member is a dict with keys of &quot;u&quot;, &quot;v&quot;, to correspond                to each component of the wind field and &quot;x&quot;, &quot;y&quot;, &quot;z&quot;                to correspond to the location of the point observation. In addition, &quot;site_id&quot; gives the METAR code (or name) to the station. * <strong>Cp</strong> (<em>float</em>) -- The weighting coefficient of the point cost function. * <strong>roi</strong> (<em>float</em>) -- Radius of influence of observations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.cost_functions.calculate_point_gradient.html#pydda.cost_functions.calculate_point_gradient" title="pydda.cost_functions.calculate_point_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_point_gradient</span></code></a>(u, v, x, y, z, ...)</p></td>
<td><p>Calculates the gradient of the cost function related to point observations. A mean square error cost function term is applied to points that are within the sphere of influence whose radius is determined by <em>roi</em>. :Parameters: * <strong>u</strong> (<em>Float array</em>) -- Float array with u component of wind field              * <strong>v</strong> (<em>Float array</em>) -- Float array with v component of wind field              * <strong>x</strong> (<em>Float array</em>) -- X coordinates of grid centers              * <strong>y</strong> (<em>Float array</em>) -- Y coordinates of grid centers              * <strong>z</strong> (<em>Float array</em>) -- Z coordinated of grid centers              * <strong>point_list</strong> (<em>list of dicts</em>) -- List of point constraints. Each member is a dict with keys of &quot;u&quot;, &quot;v&quot;,                to correspond to each component of the wind field and &quot;x&quot;, &quot;y&quot;, &quot;z&quot;                to correspond to the location of the point observation. In addition, &quot;site_id&quot; gives the METAR code (or name) to the station. * <strong>Cp</strong> (<em>float</em>) -- The weighting coefficient of the point cost function. * <strong>roi</strong> (<em>float</em>) -- Radius of influence of observations.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="retrieval-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">retrieval</span></code> Module<a class="headerlink" href="#retrieval-module" title="Permalink to this headline">#</a></h2>
<p>Main module for wind retrieval.</p>
<span class="target" id="module-pydda.retrieval"></span><section id="pydda-retrieval-pydda-retrieval">
<h3>pydda.retrieval (pydda.retrieval)<a class="headerlink" href="#pydda-retrieval-pydda-retrieval" title="Permalink to this headline">#</a></h3>
<p>The module containing the core techniques for the multiple doppler
wind retrieval. The <a class="reference internal" href="generated/pydda.retrieval.get_dd_wind_field.html#pydda.retrieval.get_dd_wind_field" title="pydda.retrieval.get_dd_wind_field"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_dd_wind_field()</span></code></a> procedure is the
primary wind retrieval procedure in PyDDA. It contains the optimization
loop that calls all of the cost functions and gradients in
<a class="reference internal" href="#module-pydda.cost_functions" title="pydda.cost_functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydda.cost_functions</span></code></a> so that the user does not need to know
how to call these functions.</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.retrieval.get_dd_wind_field.html#pydda.retrieval.get_dd_wind_field" title="pydda.retrieval.get_dd_wind_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dd_wind_field</span></code></a>(Grids, u_init, v_init, w_init)</p></td>
<td><p>This function takes in a list of Py-ART Grid objects and derives a wind field.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.retrieval.get_bca.html#pydda.retrieval.get_bca" title="pydda.retrieval.get_bca"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_bca</span></code></a>(rad1_lon, rad1_lat, rad2_lon, ...)</p></td>
<td><p>This function gets the beam crossing angle between two lat/lon pairs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.retrieval.DDParameters.html#pydda.retrieval.DDParameters" title="pydda.retrieval.DDParameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DDParameters</span></code></a>()</p></td>
<td><p>This is a helper class for inserting more arguments into the <a class="reference internal" href="generated/pydda.cost_functions.J_function.html#pydda.cost_functions.J_function" title="pydda.cost_functions.J_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">pydda.cost_functions.J_function()</span></code></a> and <a class="reference internal" href="generated/pydda.cost_functions.grad_J.html#pydda.cost_functions.grad_J" title="pydda.cost_functions.grad_J"><code class="xref py py-func docutils literal notranslate"><span class="pre">pydda.cost_functions.grad_J()</span></code></a> function.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="vis-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">vis</span></code> Module<a class="headerlink" href="#vis-module" title="Permalink to this headline">#</a></h2>
<p>Visualization module for PyDDA.</p>
<span class="target" id="module-pydda.vis"></span><section id="pydda-vis-pydda-vis">
<h3>pydda.vis (pydda.vis)<a class="headerlink" href="#pydda-vis-pydda-vis" title="Permalink to this headline">#</a></h3>
<p>A visualization module for plotting generated wind fields. There is basic
support for the visualization of wind fields over a given background field
using barbs, streamlines, and quivers.</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_barbs.html#pydda.vis.plot_horiz_xsection_barbs" title="pydda.vis.plot_horiz_xsection_barbs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_barbs</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA using barbs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_barbs.html#pydda.vis.plot_xz_xsection_barbs" title="pydda.vis.plot_xz_xsection_barbs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_xz_xsection_barbs</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the X-Z plane using barbs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_barbs.html#pydda.vis.plot_yz_xsection_barbs" title="pydda.vis.plot_yz_xsection_barbs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_yz_xsection_barbs</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the Y-Z plane using barbs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_barbs_map.html#pydda.vis.plot_horiz_xsection_barbs_map" title="pydda.vis.plot_horiz_xsection_barbs_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_barbs_map</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA onto a geographical map using barbs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_streamlines.html#pydda.vis.plot_horiz_xsection_streamlines" title="pydda.vis.plot_horiz_xsection_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_streamlines</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA using streamlines.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_streamlines.html#pydda.vis.plot_xz_xsection_streamlines" title="pydda.vis.plot_xz_xsection_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_xz_xsection_streamlines</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the X-Z plane using streamlines.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_streamlines.html#pydda.vis.plot_yz_xsection_streamlines" title="pydda.vis.plot_yz_xsection_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_yz_xsection_streamlines</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the Y-Z plane using streamlines.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_streamlines_map.html#pydda.vis.plot_horiz_xsection_streamlines_map" title="pydda.vis.plot_horiz_xsection_streamlines_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_streamlines_map</span></code></a>(Grids[, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA using streamlines.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_quiver.html#pydda.vis.plot_horiz_xsection_quiver" title="pydda.vis.plot_horiz_xsection_quiver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_quiver</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA using quivers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_xz_xsection_quiver.html#pydda.vis.plot_xz_xsection_quiver" title="pydda.vis.plot_xz_xsection_quiver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_xz_xsection_quiver</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the X-Z plane using quivers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.vis.plot_yz_xsection_quiver.html#pydda.vis.plot_yz_xsection_quiver" title="pydda.vis.plot_yz_xsection_quiver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_yz_xsection_quiver</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a cross section of winds from wind fields generated by PyDDA in the Y-Z plane using quivers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.vis.plot_horiz_xsection_quiver_map.html#pydda.vis.plot_horiz_xsection_quiver_map" title="pydda.vis.plot_horiz_xsection_quiver_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_horiz_xsection_quiver_map</span></code></a>(Grids[, ax, ...])</p></td>
<td><p>This procedure plots a horizontal cross section of winds from wind fields generated by PyDDA using quivers onto a geographical map.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="initalization-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">initalization</span></code> Module<a class="headerlink" href="#initalization-module" title="Permalink to this headline">#</a></h2>
<p>The module for creating custom initial states for the PyDDA retrieval.</p>
<span class="target" id="module-pydda.initialization"></span><section id="pydda-initialization-pydda-initialization">
<h3>pydda.initialization (pydda.initialization)<a class="headerlink" href="#pydda-initialization-pydda-initialization" title="Permalink to this headline">#</a></h3>
<p>The module containing the core techniques for the multiple doppler
wind retrieval. All of these techniques take in data from
a desired format and will return a 3-tuple of numpy arrays that
are in the same shape as the input Py-ART Grid object used
for analysis. If you wish to add another initialization here,
add a procedure that takes in a Py-Art Grid that is used for
the grid specification (shape, x, y, z) and the dataset of your
choice. Your output from the function should then be a 3-tuple
of numpy arrays with the same shape as the fields in Grid.</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.initialization.make_constant_wind_field.html#pydda.initialization.make_constant_wind_field" title="pydda.initialization.make_constant_wind_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_constant_wind_field</span></code></a>(Grid[, wind, vel_field])</p></td>
<td><p>This function makes a constant wind field given a wind vector.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.initialization.make_wind_field_from_profile.html#pydda.initialization.make_wind_field_from_profile" title="pydda.initialization.make_wind_field_from_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_wind_field_from_profile</span></code></a>(Grid, profile)</p></td>
<td><p>This function makes a 3D wind field from a sounding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.initialization.make_background_from_wrf.html#pydda.initialization.make_background_from_wrf" title="pydda.initialization.make_background_from_wrf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_background_from_wrf</span></code></a>(Grid, file_path, ...)</p></td>
<td><p>This function makes an initalization field based off of the u and w from a WRF run.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.initialization.make_initialization_from_era_interim.html#pydda.initialization.make_initialization_from_era_interim" title="pydda.initialization.make_initialization_from_era_interim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_initialization_from_era_interim</span></code></a>(Grid[, ...])</p></td>
<td><p>This function will read ERA Interim in NetCDF format and add it to the Py-ART grid specified by Grid.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="constraints-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">constraints</span></code> Module<a class="headerlink" href="#constraints-module" title="Permalink to this headline">#</a></h2>
<p>The module for creating custom constraints (i.e. from models, satellites) for the PyDDA retrieval.</p>
<span class="target" id="module-pydda.constraints"></span><section id="pydda-constraints-pydda-constraints">
<h3>pydda.constraints (pydda.constraints)<a class="headerlink" href="#pydda-constraints-pydda-constraints" title="Permalink to this headline">#</a></h3>
<p>The procedures in this module are used to add spatial fields from non-radar
based datasets for use as a constraint. The model cost function uses the
observations inserted into the Grid object from these procedures as a
constraint. In order to develop your own custom constraint here, simply
create a function that adds 3 fields into the input Py-ART Grid with names
“u_(name)”, “v_(name)”, and “w_(name)” where (name) is the name of your
dataset. Then, in order to have PyDDA use this dataset as a constraint,
simply add (name) into the model_fields option of
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_dd_wind_field()</span></code>.</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.constraints.make_constraint_from_wrf.html#pydda.constraints.make_constraint_from_wrf" title="pydda.constraints.make_constraint_from_wrf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_constraint_from_wrf</span></code></a>(Grid, file_path, ...)</p></td>
<td><p>This function makes an initalization field based off of the u and w from a WRF run in netCDF format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.constraints.add_hrrr_constraint_to_grid.html#pydda.constraints.add_hrrr_constraint_to_grid" title="pydda.constraints.add_hrrr_constraint_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_hrrr_constraint_to_grid</span></code></a>(Grid, file_path)</p></td>
<td><p>This function will read an HRRR GRIB2 file and create the constraining u, v, and w fields for the model constraint</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.constraints.make_constraint_from_era_interim.html#pydda.constraints.make_constraint_from_era_interim" title="pydda.constraints.make_constraint_from_era_interim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_constraint_from_era_interim</span></code></a>(Grid[, ...])</p></td>
<td><p>This function will read ERA Interim in NetCDF format and add it to the Py-ART grid specified by Grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/pydda.constraints.download_needed_era_data.html#pydda.constraints.download_needed_era_data" title="pydda.constraints.download_needed_era_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">download_needed_era_data</span></code></a>(Grid, start_date, ...)</p></td>
<td><p>This function will download the ERA interim data in the region specified by the input Py-ART Grid within the interval specified by start_date and end_date.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/pydda.constraints.get_iem_obs.html#pydda.constraints.get_iem_obs" title="pydda.constraints.get_iem_obs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_iem_obs</span></code></a>(Grid[, window])</p></td>
<td><p>Returns all of the station observations from the Iowa Mesonet for a given Grid in the format needed for PyDDA.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../source/auto_examples/plot_fun_with_constraints.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Example on geographic plotting and constraint variation</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="generated/pydda.cost_functions.J_function.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">pydda.cost_functions.J_function</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2023, PyDDA Developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>